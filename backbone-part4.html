<div>
  <!-- Introduction -->
  <section>
    <header>
      <h1>Introduction</h1>
    </header>
    <p>
      We finally made it to the 4th and final part of this Backbone Tutorial Series! If you haven't checked 
      out the previous parts, you can get started at 
      <a href="backbone-tutorial-part-1.html">Backbone Tutorial Part 1</a>. 
    </p>
    <p>
      Now that we have gone over some of the basics of views in 
      <a href="backbone-tutorial-part-2.html">Backbone Tutorial Part 2</a> 
      and models/collections in <a href="backbone-tutorial-part-3.html">Backbone Tutorial Part 3</a>, 
      we can wrap things up with learning about routing and adding/removing products 
      from our product list.
    </p>
  </section>
  <!-- End Introduction -->

  <!-- Part 4 Goals -->
  <section>
    <header>
      <h1>Part 4 Goals</h1>
    </header>
    <ul>
      <li>Learn about the Backbone Router.</li>
      <li>Add products to product collection.</li>
      <li>Remove products from collection.</li>
      <li>Save product collection state to local storage using Backbone LocalStorage Plugin.</li>
    </ul>
  </section>
  <!-- End Part 4 Goals -->

  <!-- Part 4 Table of Contents -->
  <section>
    <header>
      <h1>Table of Contents</h1>
    </header>
    <ul>
      <li><a href="4.1">4.1 What is a Router?</a></li>
      <li><a href="4.2">4.2 App Router</a></li>
      <li><a href="4.3">4.3 Local Storage</a></li>
      <li><a href="4.4">4.4 Product Service</a></li>
      <li><a href="4.5">4.5 Product List View</a></li>
      <li><a href="4.6">4.6 Add/Edit Product View</a></li>
      <li><a href="4.7">4.7 Delete Product</a></li>
      <li><a href="4.8">4.8 Tutorial Summary</a></li>
    </ul>
  </section>
  <!-- End Part 4 Table of Contents -->

  <!-- 4.1 What is a Router? -->
  <section id="4.1">
    <header>
      <h1>4.1 What is a Router?</h1>
    </header>
    <p>
      A <b>Backbone Router</b> is in charge of keeping track of <strong>page state</strong>. Since we are using 
      a <b>Single Page Application (SPA)</b> structure, and that requires only one html 
      page to be used, we have to keep track of what the user should be seeing and what 
      actions are being made. The router allows the application to know such a thing. 
      For example, lets say the home view is showing a list of products, and we click on one 
      of the products to bring up a single product view. The router will keep track of which product 
      was selected, and the single product view will then be rendered with the appropriate product 
      displayed. By using a router, if a user leaves and comes back to our app, 
      the app can reload were they left off.
    </p>

    <h2>How the Router Works</h2>
    <p>
      The <b>router</b> works by using the <b>url hash</b>, or the <b>History API</b> if your browser/device 
      supports it. It basically works kind of like the url querystring if you were to create 
      your website with something like PHP.
    </p>

    <h2>Basic Router</h2>
    <div class="fig">
      <pre><code class="prettyprint">// define router
var router = Backbone.Router.extend({
  routes: {
    'user/edit:id': 'editUser', // example url: '#user/edit/11' the id 11 will be passed
    'user/delete:id': 'deleteUser', // example url: '#user/delete/22' the id 22 will be passed
    '*actions': 'home' // default page state action if none of the other routes occurred
  }
});   

// listen to router events
router.on('route:editUser', function(id){
  // edit user action triggered
  // apply rest of code
});

router.on('route:deleteUser', function(id){
  // delete user action triggered
  // apply rest of code
});  

router.on('route:home', function(){
  // show home view
});

// start listening for the page history
Backbone.history.start();
</code></pre>
      <div class="fig-title">Extending Router Class</div>
    </div>
    <p>
      Just like views, models, and collections, to create a Backbone Router, you extend 
      Backbone's Router Class. The <strong>routes</strong> property is all the routes that the 
      page can take. The <b>router</b> then registers what route event will be triggered if one of the 
      expressions is matched. For example, if the url of the page is <b>www.mysite.com/index.html#user/edit/11</b>, 
      the route editUser will be triggered, and the function that is associated to 
      that route from the <strong>on()</strong> method, will be executed. By using ":id", or any other variable name 
      with a prefix ":", that value will be sent as a param for the function that is being executed. 
      If there isn't a matching route, the default route will be triggered. The 
      "*actions" matches all actions that are made to the router, and will only be triggered 
      if none of the other actions were matched before it.
    </p>
  </section>
  <!-- End 4.1 What is a Router -->

  <!-- 4.2 App Router -->
  <section>
    <header>
      <h1>4.2 App Router</h1>
    </header>
    <p>
      Now with a little understanding of what routers are and how they work, lets 
      start implementing our own router in our application.
    </p>

    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone'
], function(Backbone){
  // create class
  var AppRouter = Backbone.Router.extend({
    routes: {
      'product/add'      : 'addProduct',
      'product/edit/:id' : 'editProduct',
      '*actions'         : 'home'
    }
  });
  
  // return created class
  return AppRouter;
});    
</code></pre>
      <div class="fig-title">root/app/router.js</div>
    </div>
    <p>
      The router that we created has three routes.
    </p>
    <ul>
      <li>
        When the url is <strong>#product/add</strong>, the <strong>route:addProduct</strong> event will be triggered, notifying that 
        adding a product has been requested.
      </li>
      <li>
        When the url is <strong>#product/edit/id</strong>, where <strong>id</strong> is the id for the product to be edited. The <strong>route:editProduct</strong> 
        will be triggered, notifying that editing a product has been requested.
      </li>
      <li>
        Any other url will have the default actions route, and the <strong>route:home</strong> will 
        be triggered, notifiying that the home view is requested.
      </li>
    </ul>

    <h2>Implmenting App Router</h2>
    <p>
      With our App Router created, let's go and start implementing the router functionality to 
      our app class located at <b>root/app/app.js</b>.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone',
  'router',
  'views/home/part-f'
], function(Backbone, AppRouter, HomeView){  
  var App = {
    /**
     * The current view the application is displaying.
     * @property _curView
     * @type Backbone.View
     * @default null
     * @private
     * @since 1.0.0
     */
    _curView: null,
    
    /**
     * Initializes the application.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(){ 
      this.configureRouter();
    },
    
    /**
     * Configures the router's route handlers and start the navigation process.
     * @method configureRouter.
     * @chainable
     * @since 1.0.0
     */
    configureRouter: function(){
      // configure AppRouter actions
      var router = new AppRouter(),
          that   = this;
      
      router.on('route:home', function(){
        that.openView(HomeView);
      });

      router.on('route:addProduct', function(){
        alert('Add Product Requested!');
      });
      
      router.on('route:editProduct', function(productId){
        alert('Edit Product Requested for product id: ' + productId);
      });
      
      this.configureAppEvents(router);
      
      // start router
      Backbone.history.start();
      
      // return this for chaining
      return this;
    },
    
    /**
     * Opens the view based on the specified view class and sends in the view options 
     * to the view when it's created.
     * @param {Backbone.View} ViewClass the View Class to create an instance from.
     * @param {PlainObject} viewOptions the options to pass to the view class instance.
     * @chainable
     * @since 1.0.0
     */
    openView: function(ViewClass, viewOptions){      
      this._curView = new ViewClass(viewOptions);
      
      // return this for chaining
      return this;
    }
  };
  
  return App;
});
        
</code></pre>
      <div class="fig-title">root/app/app.js</div>
    </div>
    <p>
      Our main app file has now changed quite a bit. No longer are we directly specifing the 
      current view to be home view, but instead using the router's <strong>on()</strong> method to specify 
      when the <strong>route:home</strong> event is triggered to show our home view, in which case is the 
      default action. Also, we now have an <strong>openView()</strong> method, which in turn opens 
      the new specified view and passes any view parameters to the view when it's 
      initialized. We have separated this call so it will be easier in the future to 
      open various views depending on what state the page is in based off of our 
      router.
    </p>
    <p>
      Also, take note of the <strong>Backbone.history.start()</strong> call. That lets the router 
      know it's time to start keeping track of page state. Without it, your view will not be opened, 
      and your products will not be seen since HomeViewPartF was never created in that 
      case.
    </p>

    <h2>Refresh index.html in Browser</h2>
    <p>
      If you refresh your <b>index.html</b> page in your browser, you will see nothing has really 
      changed asthetically, however we now have our router setup for adding/editing 
      our products.
    </p>
    <div class="fig">
      <img src="images/backbone-tutorial-fig4_2a.jpg">
      <div class="fig-title">Fig 4.2a (index.html)</div>
    </div>
    <p>
      To see the router in action, add <strong>#product/add</strong> to the end of your url. So if your url is currently 
      <strong>yourpath/backbone-tutorial-walkthrough/index.html</strong>, have it look like 
      <strong>yourpath/backbone-tutorial-walkthrough/index.html#product/add</strong> and press enter. 
      You should now see an alert letting you know what you have selected. In this case, 
      we setup alerts for the add and edit routes just for demonstration purposes. 
      We will be implmenting there actual functionality shortly.
    </p>
  </section>
  <!-- End 4.2 App Router -->

  <!-- 4.3 Local Storage -->
  <section id="4.3">
    <header>
      <h1>4.3 Local Storage</h1>
    </header>
    <p>
      With our router now setup, we can now think about implementing user defined 
      data to our app. Firstly, we need to setup our models to work with some sort of 
      persistant storage so that when a user makes changes, that data will be stored. 
      Instead of setting up a database server, we will be using the web browser's 
      <b>localstorage</b>. We will be using the backbone-localstorage plugin located at 
      <b>root/app/vendor/backbone-localstorage</b> to get this functionality.
    </p>

    <h2>Adding Local Storage to Product Model</h2>
    <p>
      Open <b>root/app/models/product.js</b>, and update the file so it looks like the 
      following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone',
  <strong>'localstorage'</strong>
], function(Backbone){
  // create model, extending Backbone's Model Class
  var ProductModel = Backbone.Model.extend({
    defaults: {
      name: '',
      category: '',
      description: ''
    },

    <strong>localStorage: new Backbone.LocalStorage('products')</strong>
  });
  
  // return created model
  return ProductModel;
});
        
</code></pre>
      <div class="fig-title">root/app/models/product.js</div>
    </div>
    <p>
      The first change is set to define the localstorage plugin to be used (if you look at the 
      <b>root/app/require-config.js</b> file, you will see I already defined <b>localstorage</b> 
      and the file it referes to). Then we defined a localStorage property that 
      the backbone localstorage automatically will use during any sync operations (save/fetch/etc) the 
      model does. Normally, if you had a database server, you would specify a url 
      property for the sync operations, however since we are using localstorage, 
      we don't need to specify such a url.
    </p>
    <p>
      The LocalStorage plugin attaches a LocalStorage class to Backbone automatically. 
      If you didn't define localstorage, Backbone.LocalStorage would be undefined since 
      it's not offically part of the Backbone framework. When creating a new 
      Backbone.LocalStorage instance, we specify the key for the localstorage to use 
      when storing our data. In this case we set our key as 'products', so if you 
      want to fetch the localstorage data for products, you would use the 'products' key.
      We will use this same key to add localstorage functionality to our product collection 
      so that we may fetch all products within our collection.
    </p>

    <h2>Adding Local Storage to Product Collection</h2>
    <p>
      To be able to fetch all our products, we will have to also attach a localstorage 
      property to our product collection to allow access to the products data.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone',
  'models/product'
], function(Backbone, ProductModel){
  // create class
  var ProductCollection = Backbone.Collection.extend({
    model: ProductModel,
    <strong>localStorage: new Backbone.LocalStorage('products')</strong>
  });
  
  // return created class
  return ProductCollection;
});
        
</code></pre>
      <div class="fig-title">root/app/collections/product.js</div>
    </div>
    <p>
      Once saved, we have our products setup to now use <b>localstorage</b> for saving 
      and fetching persistant data throughout our app.
    </p>
  </section>
  <!-- End 4.3 Local Storage -->

  <!-- 4.4 Product Service -->
  <section id="4.4">
    <header>
      <h1>4.4 Product Service</h1>
    </header>
    <p>
      If you are familiar with AngularJS, then you know that when dealing with getting 
      data from a database or localstorage, you use a <b>Service Class</b>. In Backbone, 
      you don't have services just models and collections and is not required, 
      however I like to include a similiar idea in my own applications.
    </p>
    <p>
      My adapation of the service class allows for multiple different uses including the following.
    </p>
    <ul>
      <li>Fetching data from server only once in the app lifecycle.</li>
      <li>Forcing refreshing of data from the server.</li>
      <li>Fetching dummy data for testing purposes.</li>
      <li>
        Building models and collection of models with sent in raw plain object data. 
        This allows for creating models and collections without having to import each 
        respected class in a file. Just another option for creating the correct object 
        with the specified raw data.
      </li>
      <li>A more effective way for dealing with data within the entire application.</li>
    </ul>
    <p>
      With all that being said, let's create our product service.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

/**
 * The service for dealing with products.
 * File: app/services/product.js
 * Authors: Brandon Sherette
 * @class ProductService
 * @since 1.0.0
 */
define([
  'underscore',
  'jquery',
  'collections/product',
  'models/product'
], function(_, $, ProductCollection, ProductModel){
  var ProductService = {
    /**
     * The data stored for this service.
     * @property data
     * @type ProductCollection
     * @default null
     * @since 1.0.0
     */
    data: null,
    
    /**
     * Whether or not data has already been loaded from the server/localstorage.
     * Used to help prevent more calls to server than nessessary.
     * @property dataLoaded
     * @type Boolean
     * @default false
     * @since 1.0.0
     */
    dataLoaded: false,
    
    /**
     * Builds a service model with the specified properties.
     * @method buildModel
     * @param {PlainObject} properties the plain object of properties to apply to the newly built model.
     * @return {ProductModel} the newly created model.
     * @since 1.0.0
     */
    buildModel: function(properties){
      return new ProductModel(properties);
    },
    
    /**
     * Builds a model collection based on the options provided.
     * If an array of objects is sent, all objects will be created into the model for this service and added to that model's collection.
     * If options is an object, that single object will be created is the service's model and will be the single entity to the returned collection.
     * If no options are provided, then an empty collection will be returned.
     * @method buildModelCollection
     * @param {Array|Object} options an array of objects to create a collection from or a single object to add to an empty collection.
     * @return {ProductCollection} the built model collection.
     * @since 1.0.0
     */
    buildModelCollection: function(options){
      var collection = new ProductCollection();
      
      if(Array.isArray(options)){
        _.each(options, function(properties){
          collection.add(this.buildModel(properties));
        });
      }else if(typeof options === 'object'){
        collection.add(this.buildModel(options));
      }
      
      return collection;
    },
    
    /**
     * Fetches data from the server/localstorage.
     * @param {Boolean} [forceRefresh=false] force the data to be refreshed from the server if set to true, false to use data already loaded.
     * @param {Boolean} [useDummyData=false] whether or not to use dummy data while fetching data (used for testing).
     * @return {promise} the deferred promise that the data has been fetched from the server/localstorage.
     * @since 1.0.0
     */
    fetch: function(forceRefresh, useDummyData){
      var that = this,
          products = new ProductCollection(),
          deferred = $.Deferred();
      
      // don't load if data has already been loaded and forceRefresh wasn't requested
      // prevent unessessary server calls if forceRefresh isn't called
      if(this.dataLoaded && !forceRefresh){
        deferred.resolve({
          msg: 'Get Completed'
        });
        
        // prevent further execution since data has already been loaded previously
        return deferred.promise();
      }
      
      // Dummy Data Process
      if(useDummyData){
        return this.fetchDummyData();
      }
      
      // Fetch Actual Data Process
      return products.fetch().then(function(){
        that.dataLoaded = true;
        that.data = products;
      });
    },
    
    /**
     * Fetches dummy data for this service.
     * @method fetchDummyData
     * @return {promise} the deferred promise that the dummy data has been fetched.
     * @since 1.0.0
     */
    fetchDummyData: function(){
      var deferred = $.Deferred(),
          that = this;
      
      // simulate waiting for server response
      window.setTimeout(function(){
        that.data = that.getDummyData();
        that.dataLoaded = true;
        deferred.resolve({
          msg: 'Get Completed'
        });
      }, 1000);
        
      return deferred.promise();
    },
    
    /**
     * Gets dummy service data. 
     * This is used to test and simulate data from the server. 
     * Used by fetch if useDummyData option is set to true.
     * @method getDummyData
     * @return {ProductCollection} the collection of products.
     * @since 1.0.0
     */
    getDummyData: function(){
      var productCollection = new ProductCollection([
        new ProductModel({
          name: 'Pencil',
          category: 'Office Supplies',
          description: 'A basic #2 Pencil, useful for writing notes.'
        }),
        new ProductModel({
          name: 'Notebook',
          category: 'Office Supplies',
          description: 'A book for writing down your thoughts.'
        }),
        new ProductModel({
          name: 'CD Player',
          category: 'Electronics',
          description: 'Plays your music cds.'
        })
      ]);
      
      return productCollection;
    },
    
    /**
     * Saves the specified model to the server/localstorage. 
     * Adds/updates that specified model to the services model collection.
     * @method save
     * @param {Backbone.Model} model the model to save.
     * @return {promise} the deferred promise that the model will be saved.
     * @since 1.0.0
     */
    save: function(model){
      var updateModel = this.getModel(model),
          deferred = $.Deferred(),
          that = this;
      
      if(updateModel){
        // update the found model with the model to saves attributes
        updateModel.set(model.attributes);
      }else{
        updateModel = model;
      }
      
      return updateModel.save().then(function(){
        if(!that.data){
          console.log('new data');
          that.data = new ProductCollection([
            model
          ]);
        }else{
          console.log('update data');
          that.data.set(model, {
            remove: false
          });
        }
        
        deferred.resolve({
          msg: 'Save Successful'
        });
      });
      
      return deferred.promise();
    },
    
    /**
     * Removes the specified model from the product collection and from storage.
     * @method destroy
     * @param {Backbone.Model|String} model the backbone model or id for the model to destroy.
     * @returns {promise} the deferred promise that the model will be destroyed.
     * @since 1.0.0
     */
    destroy: function(model){
      var deferred = $.Deferred();
      
      // id can be used, if string assume id
      if(typeof model === 'string'){
        model = this.getModel(model);
      }
      
      if(model){
        return model.destroy();
      }else{
        deferred.reject({
          msg: 'Product Not Found'
        });
      }
      
      return deferred.promise();
    },
    
    /**
     * Gets the specified model from the service collection.
     * @method getModel
     * @param {Backbone.Model|String} model the backbone model, or id, or cid of the model to find in the service.
     * @return {Backbone.Model|null} returns the found model in the service, returns null if no match was found.
     * @since 1.0.0
     */
    getModel: function(model){
      if(this.data){
        return this.data.get(model);
      }
      
      return null;
    }
  };
  
  return ProductService;
});   
</code></pre>
      <div class="fig-title">root/app/services/product.js</div>
    </div>
    <p>
      Go ahead and read the comments for each method to get a better idea of what 
      purpose each serve. The main key point is the fetch method, which depending on 
      the specified param values, will fetch dummy data or force the data to be refreshed from the 
      server. If the data hasn't been fetched from the server already, it will automatically 
      fetch the data from the server regardless. The data is then cached in the data 
      property, which in this case will be a ProductCollection instance. The property 
      is called data instead of collection or products because that way the API for 
      all services will be the same regardless of what type of data is being used. 
      This would be a good case to create our own base Service class, however that is 
      out of the scope of this tutorial, but could be a great exercise.
    </p>
  </section>
  <!-- End 4.4 Product Service -->

  <!-- 4.4 Product List View -->
  <section id="4.5">
    <header>
      <h1>4.5 Product List View</h1>
    </header>
    <p>
      Since we are now going to go with a more dynamic set of product data, we 
      are no longer going to use the prebuilt product list that we have been using 
      in our previous home views <b>(loadModel())</b>.
    </p>
    <p>
      Open <b>root/app/views/product/list.js</b> and enter the following code.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'underscore',
  'jquery',
  'backbone',
  'services/product',
  'views/product/item'
], function(_, $, Backbone, ProductService, ProductItemView){
  var ProductListView = Backbone.View.extend({
    el: '#view-content',
    
    template: _.template($('#tplProductList').html()),
    
    model: null,

    initialize: function(){
      this.loadModel();
    },
    
    loadModel: function(){
      var that = this;
      
      ProductService.fetch().then(function(){
        that.model = ProductService.data;
        // data has been found, render the view
        that.render();
      }, function(response){
        alert('Server Error - ' + response.msg);
      });
    },
    
    /**
     * Closes the view.
     * Unbinds any events, empties the contents of the view, and stops listening to any other events.
     * @method close
     * @chainable
     * @since 1.0.0
     */
    close: function(){
      this.$el.unbind();
      this.$el.empty();
      this.stopListening();
    },
    
    /**
     * Renders the view to the page.
     * @method render
     * @chainable
     * @since 1.0.0
     */
    render: function(){
      var $productList;
      
      // apply the compiled html template to this view's jquery element, sending in the data the view will apply
      this.$el.html(this.template({
        productsMsg: (this.model.length === 0) ? 'No Products Found' : ''
      }));
      
      // capture product list element to apply data to
      $productList = this.$el.find('.product-list');
      
      // add to the product list portion of this view
      this.model.each(function(product){
        var mProductItemView = new ProductItemView({
          model: product
        });
        
        $productList.append(mProductItemView.render().el);
      });
      
      // return this for chaining
      return this;
    }
  });
  
  // return the created view
  return ProductListView;
});
        
</code></pre>
      <div class="fig-title">root/app/views/product/list.js</div>
    </div>
    <p>
      This view is quite similiar to "HomeViewPartF", however there are a few key differences, 
      such as the inclusion of the close method, loadModel now utilizing the product service, 
      and render now using another view.
    </p>
    <h3>close()</h3>
    <p>
      The close() method is used to unbind any events attached to the view and empty 
      its contents. This is used for when switching to different views, which we 
      will get into once we add the add product view.
    </p>
    <h3>loadModel()</h3>
    <p>
      The loadModel() method now uses product service and sets the model data to the 
      service's data, and the render method doesn't get called until the fetch was 
      successful, if it fails to load the alert error will be triggered.
    </p>
    <h3>render()</h3>
    <p>
      The render() method now searches html element with the product-list css class, 
      this is used so that we can append the single product item view into the view. 
      This is to solve the one issue we were having with having the <b>each()</b> method in our template, 
      and allows us to further extract out JavaScript code from our templates. When 
      looping through each product, the model for the ProductItem instance is passed to it so 
      that it renders with that specific product data.
    </p>

    <h2>Product List Html Template</h2>
    <p>
      Now that our <b>ProductListView</b> is in place, we can implement the html template. 
      Open <b>root/index.html</b> in your favorite text editor, add the following template 
      code in between the <b>tplProductList</b> template script tag.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;h1 class="text-center"&gt;Products&lt;/h1&gt;
&lt;p&gt;&lt;%= productsMsg %&gt;&lt;/p&gt;
&lt;div class="product-list"&gt;&lt;/div&gt;
&lt;br&gt;
&lt;a href="#product/add" class="btn btn-default"&gt;Add Product&lt;/a&gt;
</code></pre>
      <div class="fig-title">index.html (#tplProductList)</div>
    </div>
    <p>
      As you can probably tell, there isn't any <b>each()</b> loop in this template. This is because 
      we are now using a subview to loop through each product and append them to the <strong>.product-list</strong> 
      css class. The <strong>productsMsg</strong> will show whether or not products where found or not. 
      We have also added a button for adding a product using the url as defined in our router, 
      <strong>product/add</strong>. We will be implementing the add product view later in the tutorial.
    </p>

    <h2>ProductItemView</h2>
    <p>
      With ProductListView created and utilizing a ProductItemView, we will now 
      create the ProductItemView. This view is a view pertaining to only one product item, 
      where as the ProductListView contains multiple instances of ProductItemView that 
      append to the product-list class in our template.
    </p>
    <p>
      Open <b>root/app/views/product/item.js</b> and add the following code.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

/**
 * Product Item View
 * Shows the product and description type details, shows pretty much everything for the item to the user.
 * File: app/views/product/item.js
 * Authors: Brandon Sherette
 * @class ProductItemView
 * @extends Backbone.View
 * @version 1.0.0
 */
define([
  'underscore',
  'jquery',
  'backbone',
  'models/product'
], function(_, $, Backbone, ProductModel){
  var ProductItemView = Backbone.View.extend({
    /**
     * The tag name to use to render the view into.
     * @property div
     * @type String
     * @since 1.0.0
     */
    tagName: 'div',
    
    /**
     * The name of the css class to apply to the view's tag.
     * @property className
     * @type String
     * @since 1.0.0
     */
    className: 'product-item',
    
    /**
     * The template to use for this view. Contains the html to use.
     * @property template
     * @since 1.0.0
     */
    template: _.template($('#tplProductItem').html()),
    
    /**
     * The model attached to this view.
     * @property model
     * @type ProductModel
     * @default null
     * @since 1.0.0
     */
    model: null,
    
    /**
     * Initializes this view. This is called when the view is created.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(options){
      this.loadModel(options);
    },
    
    /**
     * Loads the model for this view (fetches the data).
     * Calls this view's render once the data has been fetched.
     * @method loadModel
     * @since 1.0.0
     */
    loadModel: function(options){
      options = options || {};
      
      if(options.hasOwnProperty('model')){
        this.model = options.model;
      }else{
        // no model found
        this.model = new ProductModel();
      }
    },

    /**
     * Closes the view.
     * Unbinds any events, empties the contents of the view, and stops listening to any other events.
     * @method close
     * @chainable
     * @since 1.0.0
     */
    close: function(){
      this.$el.unbind();
      this.$el.empty();
      this.stopListening();
    },
    
    /**
     * Renders the view to the page.
     * @method render
     * @chainable
     * @since 1.0.0
     */
    render: function(){
      // apply the compiled html template to this view's jquery element, sending in the data the view will apply
      this.$el.html(this.template({
        product: this.model.toJSON()
      }));
      
      // return this for chaining
      return this;
    }
  });
  
  // return the created view
  return ProductItemView;
});   
</code></pre>
      <div class="fig-title">root/app/views/product/item.js</div>
    </div>
    <p>
      One key difference in the ProductListView over other views we have created so far is 
      that the <strong>loadModel()</strong> will check if a model option was provided and will set 
      the model's data to that. We do this since we already have the data readily available from the 
      parent view.
    </p>

    <h2>ProductItemView Template</h2>
    <p>
      If you haven't already, open <b>root/index.html</b>, and then update the template 
      script tag "tplProductItem" with the following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;div class="heading-group"&gt;
  &lt;h2&gt;&lt;%= product.name %&gt;&lt;/h2&gt;
  &lt;h3 class="subheading"&gt;&lt;%= product.category %&gt;&lt;/h3&gt;
&lt;/div&gt;
&lt;p&gt;&lt;%= product.description %&gt;&lt;/p&gt;
&lt;p&gt;
  &lt;span&gt;&lt;a href="#product/edit/&lt;%= product.id %&gt;"&gt;edit&lt;/a&gt;&lt;/span&gt;
&lt;/p&gt;   
</code></pre>
      <div class="fig-title">root/index.html (#tplProductItem)</div>
    </div>
    <p>
      In this template we added the rest of our router's url routes (edit) and display 
      the contents of our single product, thus avoiding using function calls in our template, such as the 
      <b>each()</b> function that we used in our previous examples.
    </p>

    <h2>Update App</h2>
    <p>
      To finish up our updates, we are going to now have our home view actually be 
      our ProductListView. Open <b>root/app/app.js</b> and edit the file to look the example 
      below.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone',
  'router',
  <strong>'views/product/list'</strong>
], function(Backbone, AppRouter, <strong>ProductListView</strong>){  
  var App = {
    /**
     * The current view the application is displaying.
     * @property _curView
     * @type Backbone.View
     * @default null
     * @private
     * @since 1.0.0
     */
    _curView: null,
    
    /**
     * Initializes the application.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(){ 
      this.configureRouter();
    },
    
    /**
     * Configures the router's route handlers and start the navigation process.
     * @method configureRouter.
     * @chainable
     * @since 1.0.0
     */
    configureRouter: function(){
      // configure AppRouter actions
      var router = new AppRouter(),
          that   = this;
      
      router.on('route:home', function(){
        <strong>that.openView(ProductListView);</strong>
      });
      
      // start router
      Backbone.history.start();
      
      // return this for chaining
      return this;
    },
    
    /**
     * Opens the view based on the specified view class and sends in the view options 
     * to the view when it's created.
     * @param {Backbone.View} ViewClass the View Class to create an instance from.
     * @param {PlainObject} viewOptions the options to pass to the view class instance.
     * @chainable
     * @since 1.0.0
     */
    openView: function(ViewClass, viewOptions){
      <strong>
      if(this._curView){
        // close current view before opening new one
        this._curView.close();
      }
      </strong>
      
      this._curView = new ViewClass(viewOptions);
      
      // return this for chaining
      return this;
    }
  };
  
  return App;
});   
</code></pre>
      <div class="fig-title">root/app/app.js</div>
    </div>
    <p>
      Instead of using the <strong>HomeView</strong>, we are just going to use <strong>ProductListView</strong> and we 
      will no longer being use the <strong>HomeView</strong> for the rest of the tutorial. In the <strong>openView()</strong> 
      method, we are now closing the previous view if there was a previous view before setting up 
      a new view. This allows the view to release any binded events or do any additional 
      clean up before moving on to the next view.
    </p>

    <h2>Refresh index.html in Browser</h2>
    <p>
      If not already opened, open <b>root/index.html</b> in your browser and notice that 
      page renders just like our previous examples, but now it should show <b>No Products Found</b> 
      and now have an <b>Add Product Button</b>.
    </p>
    <div class="fig">
      <img src="images/backbone-tutorial-fig4_4a.jpg">
      <div class="fig-title">root/index.html</div>
    </div>
  </section>
  <!-- End 4.5 Product List View -->

  <!-- 4.6 Add Product View -->
  <section id="4.6">
    <header>
      <h1>4.6 Add/Edit Product View</h1>
    </header>
    <p>
      Now that we have the <b>ProductListView</b> created, we are now pretty much set to start implementing 
      an add product view. This view will allow a user to add their 
      own products and store them to localstorage.
    </p>
    <p>
      To begin, let's open <b>root/app/views/edit.js</b> and add the following code.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

/**
 * View for editing products.
 * File: app/views/product/edit.js
 * Authors: Brandon Sherette
 * @class ProductEditView
 * @extends Backbone.View
 * @since 1.0.0
 */
define([
  'underscore',
  'jquery',
  'backbone',
  'services/product'
], function(_, $, Backbone, ProductService){
  var ProductEditView = Backbone.View.extend({
    /**
     * The element that this view will be attached to.
     * @property el
     * @type String
     * @since 1.0.0
     */
    el: '#view-content',
    
    /**
     * The template to use for this view. Contains the html to use.
     * @property template
     * @since 1.0.0
     */
    template: _.template($('#tplProductEdit').html()),
    
    /**
     * The model attached to this view.
     * @property model
     * @type ProductCollection
     * @default null
     * @since 1.0.0
     */
    model: null,
    
    /**
     * Initializes this view. This is called when the view is created.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(options){
      options = options || {};
      
      this.loadModel(options.modelId);
    },
    
    /**
     * The events attached to this view.
     * @property events
     * @type PlainObject
     * @since 1.0.0
     */
    events: {
      'keyup .form-control': 'onKeyUp',
      'click .btn-save': 'onSaveClick',
      'click .btn-cancel': 'onCancelClick'
    },
    
    /**
     * Loads the model for this view (fetches the data).
     * Calls this view's render once the data has been fetched.
     * @method loadModel
     * @since 1.0.0
     */
    loadModel: function(modelId){
      var that = this,
          model;
      
      ProductService.fetch().then(function(){
        model = ProductService.getModel(modelId);
        if(!model){
          model = ProductService.buildModel();
        }else{
          // use clone, so not to override data until save is pressed
          model = model.clone();
        }

        that.model = model;
        that.render();
      }, function(response){
        alert('Failed to load data. ' + response.msg);
      });
    },
    
    /**
     * The event that the button on the keyboard has been released (key up).
     * Bind model properties or form validation in this section for instant feedback.
     * @method onKeyUp
     * @param {Event} event the event that was triggered.
     * @since 1.0.0
     */
    onKeyUp: function(event){
      var $target = $(event.currentTarget),
          validExp = /^[\.\#\,a-zA-Z0-9\- ]+$/,
          modelProperty = $target.data('model'),
          value = $target.val();
        
      // only update if value is correct  
      if(validExp.test(value)){
        // update model property
        this.model.set(modelProperty, value);
        $target.removeClass('invalid');
      }else{
        $target.addClass('invalid');
      }
    },
    
    /**
     * Closes the view.
     * Unbinds any events, empties the contents of the view, and stops listening to any other events.
     * @method close
     * @chainable
     * @since 1.0.0
     */
    close: function(){
      this.$el.unbind();
      this.$el.empty();
      this.stopListening();
      
      return this;
    },
    
    /**
     * The event that the save button has been clicked.
     * Saves the model's data.
     * @method onSaveClick
     * @param {Event} event the event that was triggered.
     * @since 1.0.0
     */
    onSaveClick: function(event){
      // prevent default action
      if(event){
        event.preventDefault();
      }
      
      // check if form is invalid
      if($('.form-control').hasClass('invalid') || this.model.get('name').length < 1){
        alert('Form Invalid');
      }else{
        // all good
        ProductService.save(this.model).then(function(){
          Backbone.trigger('onSaveCompleted:product');
        }, function(response){
          alert('Failed to save product: ' + response.msg);
        });
      }
    },
    
    /**
     * The event that the cancel button was clicked.
     * @method onCancelClick
     * @since 1.0.0
     */
    onCancelClick: function(){
      Backbone.trigger('cancel:product');
    },
    
    /**
     * Renders the view to the page.
     * @method render
     * @chainable
     * @since 1.0.0
     */
    render: function(){
      this.$el.html(this.template({
        product: this.model.toJSON()
      }));
      
      // return this for chaining
      return this;
    }
  });
  
  return ProductEditView;
});
        
</code></pre>
      <div class="fig-title">root/app/views/edit.js</div>
    </div>
    <p>
      The <b>ProductEditView</b> will serve as both our edit and add product view. 
      The only difference between the two views, is that one is interacting with a model 
      already created, and the other is dealing with brand new copy of a <b>ProductModel</b>. 
      To differentiate between the two, we will be using the 
      model's id property. If the id sent is 0, it is assumed that a new product is requested.
    </p>

    <h2>loadModel()</h2>
    <p>
      If you look at the <strong>loadModel()</strong> method, you will see that we utilize the 
      <b>ProductService</b> that we created earlier and fetch our products data, then 
      search for the model with the specified modelId that was sent into our view from 
      our router. If no model is found, then we use the <b>ProductService</b> to create a new 
      <b>ProductModel</b> instance that will be used to create a new product with.
    </p>

    <div class="disclaimer">
      <small>
        <b>Note</b>
        <p>
          If a model is found, we set the view's model as a clone. Since objects are passed 
          by reference, we don't want to modify the current model's data until it's saved, 
          otherwise if we canceled editing the product, any changes to the model will persist 
          in the rest of the application.
        </p>
      </small>
    </div>

    <h2>events</h2>
    <p>
      We somewhat skimmed over a powerful aspect of views in 
      <a href="backbone-tutorial-part-2.html">Backbone Tutorial Part 2</a>, 
      and that is <b>events</b>. The <strong>events</strong> property in a Backbone View is used to bind events to the 
      view's jQuery element <strong>$el</strong>. In our case we used the <b>events</b> property to bind three different 
      events that we want to listen for and they include the following.
    </p>
    <dl>
      <dt>'keyup .form-control': 'onKeyUp'</dt>
      <dd>
        When the <b>keyup</b> event is triggered on the css class <b>.form-control</b>, the 
        <b>onKeyUp</b> method of the view is triggered. We use this to allow for 
        validation and updating our model as data is being entered from the user. 
        The <b>onKeyUp</b> method validates the data. If valid, it sets the data to the model.
      </dd>
      <dt>'click .btn-save': 'onSaveClick'</dt>
      <dd>
        When the <b>click</b> event is triggered on the css class <b>.btn-save</b>, the 
        <b>onSaveClick</b> method of the view is triggered. We use this event to know
        when the user is ready to save the product model. The <b>onSaveClick</b> checks 
        to make sure the form is valid before trying to save the model. If the model 
        is saved successfully, we trigger our custom Backbone event <b>onSaveCompleted:product</b> to 
        let the entire application know that the user has just completed saving a product. 
        Our router will pick up on this, and navigate to the correct coresponding page.
      </dd>
      <dt>'click .btn-cancel': 'onCancelClick'</dt>
      <dd>
        When the <b>click</b> event is triggered on the css class <b>btn-cancel</b>, the 
        <b>onCancelClick</b> method of the view is triggered. We use this event to know
        when the user wants to cancel saving the product. The <b>onCancelClick</b> method 
        will trigger the custom Backbone Event <b>cancel:product</b>. This event is used 
        to notify that the user has cancelled editing/adding a product at an application wide 
        level.
      </dd>
    </dl>
    <p>
      One of the main reasons to have a <strong>close()</strong> method in our view is because 
      the view's <b>events</b> are bound to the view's <strong>$el</strong>. The 
      <strong>close()</strong> method will unbind such events. If we didn't do this, 
      the events would still be lingering in our HTML Element, and they would still have 
      a chance to trigger even if we are not currently in the view.
    </p>

    <h2>Product View Template</h2>
    <p>
      If you haven't already, open <b>index.html</b> in your favorite text editor and update 
      the contents of the script template <b>tplProductEdit</b> with the following code.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;h1&gt;Product&lt;/h1&gt;
&lt;form role="form"&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="name"&gt;Name&lt;/label&gt;
    &lt;input type="text" class="form-control" data-model="name" value="&lt;%= product.name %&gt;"&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="category"&gt;Category&lt;/label&gt;
    &lt;input type="text" class="form-control" data-model="category" id="category" value="&lt;%= product.category%&gt;"&gt;
  &lt;/div&gt;
  &lt;div class="form-group"&gt;
    &lt;label for="description"&gt;Description&lt;/label&gt;
    &lt;textarea class="form-control" data-model="description" id="description"&gt;&lt;%= product.description %&gt;&lt;/textarea&gt;
  &lt;/div&gt;
  &lt;button type="submit" class="btn btn-default btn-save"&gt;Save&lt;/button&gt;
  &lt;button class="btn btn-default btn-cancel"&gt;Cancel&lt;/button&gt;
&lt;/form&gt;  
</code></pre>
      <div class="fig-title">index.html (#tplProductEdit)</div>
    </div>
    <p>
      We have now created the form for our product data. To help with populating the 
      product model data, we use the html attribute "data" to notify what property 
      each html form element is being used.
    </p>

    <h2>Update App</h2>
    <p>
      Like usual, we have to update <b>root/app/app.js</b> to use our newly created view. 
      After the file is open, update the file so that it matches the following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

/**
 * The main entry point for the actual app code.
 * File: app/app.js
 * Authors: Brandon Sherette
 * @class App
 * @since 1.0.0
 */
define([
  'backbone',
  'router',
  'views/product/list',
  <strong>'views/product/edit'</strong>
], function(Backbone, AppRouter, ProductListView, <strong>ProductEditView</strong>){  
  var App = {
    /**
     * The current view the application is displaying.
     * @property _curView
     * @type Backbone.View
     * @default null
     * @private
     * @since 1.0.0
     */
    _curView: null,
    
    /**
     * Initializes the application.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(){ 
      this.configureRouter();
    },
    
    /**
     * Configures the router's route handlers and start the navigation process.
     * @method configureRouter.
     * @chainable
     * @since 1.0.0
     */
    configureRouter: function(){
      // configure AppRouter actions
      var router = new AppRouter(),
          that   = this;
      
      router.on('route:home', function(){
        that.openView(ProductListView);
      });
      
      <strong>
      router.on('route:addProduct', function(){
        that.openView(ProductEditView, {modelId: 0});
      });
      
      router.on('route:editProduct', function(productId){
        that.openView(ProductEditView, {modelId: productId});
      });
      
      this.configureAppEvents(router);
      </strong>
      
      // start router
      Backbone.history.start();
      
      // return this for chaining
      return this;
    },
    
<strong>
    /**
     * Configures any app wide events.
     * @param {Backbone.Router} router the app router.
     * @chainable
     * @since 1.0.0
     */
    configureAppEvents: function(router){      
      Backbone.on('onSaveCompleted:product', function(){
        router.navigate('', {
          trigger: true
        });
      });
      Backbone.on('cancel:product', function(){
        router.navigate('', {
          trigger: true
        });
      });
      
      // return this for chaining
      return this;
    },
</strong>
    
    /**
     * Opens the view based on the specified view class and sends in the view options 
     * to the view when it's created.
     * @param {Backbone.View} ViewClass the View Class to create an instance from.
     * @param {PlainObject} viewOptions the options to pass to the view class instance.
     * @chainable
     * @since 1.0.0
     */
    openView: function(ViewClass, viewOptions){
      if(this._curView){
        // close current view before opening new one
        this._curView.close();
      }
      
      this._curView = new ViewClass(viewOptions);
      
      // return this for chaining
      return this;
    }
  };
  
  return App;
});
        
</code></pre>
      <div class="fig-title">root/app/app.js</div>
    </div>
    <p>
      You should now have it so now all our router events are now setup with adding 
      and editing products. Also, we have added a <strong>configureAppEvents()</strong> method 
      that will listen to the Backbone Events that we triggered in our edit view.
    </p>

    <h2>Refresh index.html in Browser</h2>
    <p>
      Once the changes have been made to <b>root/app/app.js</b>, you can now refresh 
      <b>index.html</b> in your browser and now you should be able to click the add product button 
      and start adding your own products.
    </p>
    <div class="fig">
      <img src="images/backbone-tutorial-fig4_6a.jpg">
      <div class="fig-title">Fig 4.6a (index.html?#/product/add)</div>
    </div>
    <div class="fig">
      <img src="images/backbone-tutorial-fig4_6b.jpg">
      <div class="fig-title">Fig 4.6b (index.html)</div>
    </div>
  </section>
  <!-- End 4.6 Add Product View -->

  <!-- 4.7 Delete Product -->
  <section id="4.7">
    <header>
      <h1>4.7 Delete Product</h1>
    </header>
    <p>
      Once you finish adding and editing products, we can now add our last feature, 
      deleting a product. We don't really need to add a view for deleting, and since we already 
      have our ProductListView with a delete link in our template, we can just add
      delete event in our <b>ProductListView</b>.
    </p>
    <p>
      Open <b>root/app/views/product/list.js</b> and update the file so it matches the 
      following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

/**
 * Product List View
 * Shows all the products in a list type format.
 * File: app/views/product/list.js
 * Authors: Brandon Sherette
 * @class ProductListView
 * @extends Backbone.View
 * @since 1.0.0
 */
define([
  'underscore',
  'jquery',
  'backbone',
  'services/product',
  'views/product/item'
], function(_, $, Backbone, ProductService, ProductItemView){
  var ProductListView = Backbone.View.extend({
    /**
     * The element to attach to this view.
     * @property el
     * @type String
     * @since 1.0.0
     */
    el: '#view-content',
    
    /**
     * The template to use for this view. Contains the html to use.
     * @property template
     * @since 1.0.0
     */
    template: _.template($('#tplProductList').html()),
    
    /**
     * The model attached to this view.
     * @property model
     * @type ProductCollection
     * @default null
     * @since 1.0.0
     */
    model: null,
    
    /**
     * Initializes this view. This is called when the view is created.
     * @method initialize
     * @since 1.0.0
     */
    initialize: function(){
      this.loadModel();
    },
    <strong>
    /**
     * The events attached to this view.
     * @property events
     * @type PlainObject
     * @since 1.0.0
     */
    events: {
      'click .delete-product': 'onDeleteProductClick'
    },
    </strong>
    /**
     * Loads the model for this view (fetches the data).
     * Calls this view's render once the data has been fetched.
     * @method loadModel
     * @since 1.0.0
     */
    loadModel: function(){
      var that = this;
      
      ProductService.fetch().then(function(){
        that.model = ProductService.data;
        // data has been found, render the view
        that.render();
      }, function(response){
        alert('Server Error - ' + response.msg);
      });
    },
    <strong>
    /**
     * The event that the delete product button has been clicked.
     * Deletes the product that the button is associated to from data-model attribute.
     * @method onDeleteProductClick
     * @param {Event} event the event that was triggered.
     * @since 1.0.0
     */
    onDeleteProductClick: function(event){
      var $target = $(event.currentTarget),
          id = $target.data('id'),
          product = ProductService.getModel(id),
          that = this;
      
      if(window.confirm('Are you sure you want to delete ' + product.get('name') + '?')){
        ProductService.destroy(id).then(function(){
          // re-render to update the changes
          that.render();
          alert('Product Deleted');
        }, function(response){
          alert('Failed to delete product. ' + response.msg);
        });
      }
    },
    </strong>
    /**
     * Closes the view.
     * Unbinds any events, empties the contents of the view, and stops listening to any other events.
     * @method close
     * @chainable
     * @since 1.0.0
     */
    close: function(){
      this.$el.unbind();
      this.$el.empty();
      this.stopListening();
    },
    
    /**
     * Renders the view to the page.
     * @method render
     * @chainable
     * @since 1.0.0
     */
    render: function(){
      var $productList;
      
      // apply the compiled html template to this view's jquery element, sending in the data the view will apply
      this.$el.html(this.template({
        productsMsg: (this.model.length === 0) ? 'No Products Found' : ''
      }));
      
      // capture product list element to apply data to
      $productList = this.$el.find('.product-list');
      
      // add to the product list portion of this view
      this.model.each(function(product){
        var mProductItemView = new ProductItemView({
          model: product
        });
        
        $productList.append(mProductItemView.render().el);
      });
      
      // return this for chaining
      return this;
    }
  });
  
  // return the created view
  return ProductListView;
});
</code></pre>
      <div class="fig-title">root/app/views/product/list.js</div>
    </div>
    <p>
      We have now added the <strong>events</strong> property to our <strong>ProductListView</strong> and its listener 
      method <strong>onDeleteProductClick()</strong>. Once the delete event is triggered and the user 
      confirms the action, the ProductService then destroys the model, then on success, 
      the view is re-rendered to show the updated product list.
    </p>

    <h2>Refresh index.html in Browser</h2>
    <p>
      Once finished, refresh <b>root/index.html</b> in your browser and try clicking the delete 
      link to one of your products and see your delete method in action.
    </p>
  </section>
  <!-- End 4.7 Delete Product -->

  <!-- 4.8 Tutorial Summary -->
  <section id="4.8">
    <header>
      <h1>4.7 Tutorial Summary</h1>
    </header>
    <p>
      <strong>Congratulations!</strong> You have now successfully created a simplfied Product Manager Application 
      utilizing the Backbone Framework.
    </p>
    <p>
      We went through several facets of Backbone, such as: views, models, and routing. 
      This has only been a small taste of what Backbone can do for you, but has given 
      you an idea of how you can build your own application.
    </p>
    <h2>More Info</h2>
    <ul>
      <li><a href="http://backbonejs.org/">Backbone Offical Website</a></li>
      <li><a href="http://underscorejs.org/">Underscore Offical Website</a></li>
      <li><a href="https://jquery.com/">jQuery Offical Website</a></li>
      <li><a href="http://requirejs.org/">RequreJS Offical Website</a></li>
    </ul>

    <p>
      I hope that this set of tutorials has helped you get a better understanding 
      of the Backbone JavaScript Framework, and enjoyed it enough to start creating 
      your own more complete applications that others can use.
    </p>
    <p>
      Good luck, have fun, and I hope to see you again soon!
    </p>
    <p>
      Brandon Sherette
    </p>
  </section>
  <!-- End 4.8 Tutorial Summary -->
</div>