<div>
  <!-- Introduction -->
  <section>
    <header>
      <h1 class="text-center">Introduction</h1>
    </header>
    <p>
      If you haven't completed the other backbone tutorial parts go to 
      <a href="backbone-tutorial-part-1.html">Backbone Tutorial Part 1</a> 
      to get started.
    </p>
    <p>
      Now that you have learned a little bit about views in 
      <a href="backbone-tutorial-part-2.html">Backbone Part 2</a>, we will begin 
      learning about creating models and applying them to our application's views.
    </p>
  </section>
  <!-- End Introduction -->

  <!-- Goals -->
  <section>
    <header>
      <h1>Part 3 Goals</h1>
    </header>
    <ul>
      <li>Learn how to create a model.</li>
      <li>Learn how to create a collection of models.</li>
      <li>Learn how to incorporate model and/or collection to a view.</li>
    </ul>
  </section>
  <!-- End Goals -->

  <!-- Table of Contents -->
  <section>
    <header>
      <h1>Table of Contents</h1>
    </header>
    <ul>
      <li><a href="#3.1">3.1 What is a Model?</a></li>
      <li><a href="#3.2">3.2 Basic Model</a></li>
      <li><a href="#3.3">3.3 Create Product Model</a></li>
      <li><a href="#3.4">3.4 Implement Product Model</a></li>
      <li><a href="#3.5">3.5 What is a Collection?</a></li>
      <li><a href="#3.6">3.6 Basic Collection</a></li>
      <li><a href="#3.7">3.7 Create Product Collection</a></li>
      <li><a href="#3.8">3.8 Implement Product Collection</a></li>
      <li><a href="#3.9">3.9 Part 2 Summary</a></li>
    </ul>
  </section>
  <!-- End Table of Contents -->

  <!-- 3.1 What is a Model? -->
  <section id="3.1">
    <header>
      <h1>3.1 What is a Model?</h1>
    </header>
    <p>
      Where as a <b>Backbone View</b> is in charge of what is displayed to a user, a 
      <b>Backbone Model</b> is in charge of containing data that is to be displayed or interacted 
      with a user. Think of a <b>Backbone Model</b> as a retainer of attributes/properites.
      For example, "User" would be considered a model and it's properties would be 
      username, firstname, lastname, and account type.
    </p>
  </section>
  <!-- End 3.1 What is a Model? -->

  <!-- 3.2 Basic Model -->
  <section id="3.2">
    <header>
      <h1>3.2 Basic Model</h1>
    </header>
    <p>
      Similar to Views, to create a <b>Backbone Model</b>, all you have to do is extend 
      Backbone's Model Class. For demonstration purposes, lets use the User Model 
      idea mentioned above, and create a basic User Model Class.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">var UserModel = Backbone.Model.extend({
  defaults: {
    username: '',
    firstname: '',
    lastname: '',
    accountType: 'general'
  }
});</code></pre>
      <div class="fig-title">User Model Example</div>
    </div>
    <p>
      What we did here was create a new Model class stored in the variable "UserModel" with 
      a username, firstname, lastname, and account type attributes. The <strong>defaults</strong> property 
      is used to define what the attributes the model has avaliable to it, and 
      what the default values for those attributes are.
    </p>

    <h2>Get/Set Attribute Values</h2>
    <p>
      To get attribute values from the model, you use the <strong>get(key)</strong> method, and to set a value 
      to a model attribute, you use the <strong>set(key, value)</strong> method.
    </p>

    <div class="fig">
      <pre><code class="prettyprint">// define model
var UserModel = Backbone.Model.extend({
  defaults: {
    username: '',
    firstname: '',
    lastname: '',
    accountType: 'general'
  }
});

// create new model instance
var user1 = new UserModel({
  username: 'jsmith11',
  firstname: 'John',
  lastname: 'Smith'
});

// getting attribute values
user1.get('username'); // returns 'jsmith11'
user1.get('firstname'); // returns 'John'
user1.get('accountType'); // returns 'general' since value wasn't specified, so the default value was used.

// setting attribute values
user1.set('firstname', 'Bob');
user1.get('firstname'); // returns 'bob' since firstname was changed using set

user1.set('accountType', 'admin');
user1.get('accountType'); // returns 'admin' 
</code></pre>
      <div class="fig-title">Get/Set Examples</div>
    </div>
  </section>
  <!-- End 3.2 Basic Model -->

  <!-- 3.3 Create Product Model -->
  <section id="3.3">
    <header>
      <h1>Create Product Model</h1>
    </header>
    <p>
      Now that we know how to define a model and get/set attribute values for a model, 
      we now have all the basics we need to start adding a product model to our 
      product manager application. First off, we will define our Product Model as shown in 
      the code below.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone'
], function(Backbone){
  // create model, extending Backbone's Model Class
  var ProductModel = Backbone.Model.extend({
    defaults: {
      name: '',
      category: '',
      description: ''
    }
  });
  
  // return created model
  return ProductModel;
});   
</code></pre>
      <div class="fig-title">Fig 3.3 (root/app/models/product.js)</div>
    </div>
    <p>
      As you can probably tell, we now have created a simple model representing our 
      product data. Now all we need to do is implment our product model into our view.
    </p>
  </section>
  <!-- End 3.3 Creating Product Model -->

  <!-- 3.4 Product Model -->
  <section id="3.4">
    <header>
      <h1>3.4 Implement Product Model</h1>
    </header>
    <p>
      Open up <b>root/app/views/home/part-d.js</b> with your favorite text editor and begin 
      adding the following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'underscore',
  'jquery',
  'backbone',
  'models/product'
], function(_, $, Backbone, ProductModel){
  var HomeViewPartD = Backbone.View.extend({
    el: '#view-content',

    template: _.template($('#tplHomePartD').html()),

    model: null,

    initialize: function(){
      this.loadModel();
    },

    loadModel: function(){
      this.model = new ProductModel({
        name: 'Pencil',
        category: 'Office Supplies',
        description: 'A basic #2 Pencil, useful for writing notes.'
      });
      
      // since data is being set and not loaded via fetch, you can call render right away
      this.render();
    },

    render: function(){      
      // apply the compiled html template to this view's jquery element
      this.$el.html(this.template({
        product: this.model
      }));
      
      // return this for chaining
      return this;
    }
  });
  
  return HomeViewPartD;
});

</code></pre>
      <div class="fig-title">root/app/views/home/part-d.js</div>
    </div>
    <p>
      As you may have noticed, there are a few main changes to our view class. We now 
      have a <strong>loadModel()</strong> method in our view, and we now send the model data to our template.
    </p>

    <h3>loadModel()</h3>
    <p>
      The loadModel method is not a default Backbone View method, but a custom 
      one that I like to use in my views to help distinquish when I'm loading 
      my model data to the view. Once the model data is loaded, I then let the view know 
      it's time to render the template.
    </p>

    <h3>render()</h3>
    <p>
      With our data now in a model, we can pass that model to our template function like shown in 
      the render method in the code above.
    </p>

    <h2>HomeViewPartD Template</h2>
    <p>
      Once you have created HomeViewPartD, you will need to create the template 
      for the view, so open up <b>root/index.html</b>, and add the following html in the 
      <b>tplHomePartD</b> id template script tag.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;h1 class="text-center"&gt;Products&lt;/h1&gt;
&lt;div class="heading-group"&gt;
  &lt;h2&gt;&lt;%= product.get('name') %&gt;&lt;/h2&gt;
  &lt;h3 class="subheading"&gt;&lt;%= product.get('category') %&gt;&lt;/h3&gt;
&lt;/div&gt;
    
&lt;p&gt;&lt;%= product.get('description') %&gt;&lt;/p&gt;
</code></pre>
      <div class="fig-title">root/index.html (#tplHomePartD)</div>
    </div>
    <p>
      As you can see, so long as you are in the &lt;% %&gt; delimeters, you case still use 
      the model's get method or any other method associated to the model since we passed the entire 
      model to the template.
    </p>

    <h2>Update App</h2>
    <p>
      All that's left to do now is to update <b>root/app.js</b> to use our new home view and 
      open/refresh index.html in your web browser.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'views/home/part-d'
], function(HomeView){
  var App = {
    _curView: null,
    
    initialize: function(){
      // start the application with the HomeView
      this._curView = new HomeView();
    }
  };
  
  return App;
});    
</code></pre>
      <div class="fig-title">root/app.js</div>
    </div>

    <h2>Refresh index.html in Browser</h2>
    <p>
      Once you have opened/refreshed <b>root/index.html</b>, the results should be similar to 
      <strong>Fig 3.4a.</strong>
    <div class="fig">
      <img src="images/backbone-tutorial-fig3_4a.jpg">
      <div class="fig-title">Fig 3.4a (root/index.html)</div>
    </div>
    </p>

    <h2>Sending Model Data as Plain Object</h2>
    <p>
      We could leave the view and template as is, and it still works with accessing the model data, however 
      it's cleaner and better to leave out as many JavaScript code and function calls from the template as possible. 
      So with that mind, what we are going to do next is update our view to send our model data as a plain 
      object to the template and interact with that data that way.
    </p>

    <h3>HomeViewPartE</h3>
    <p>
      Open "root/app/views/home/part-e.js" and add the following code.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'underscore',
  'jquery',
  'backbone',
  'models/product'
], function(_, $, Backbone, ProductModel){
  var HomeViewPartE = Backbone.View.extend({
    el: '#view-content',
    
    template: _.template($('#tplHomePartE').html()),
    
    model: null,
    
    initialize: function(){
      this.loadModel();
    },
    
    loadModel: function(){
      this.model = new ProductModel({
        name: 'Pencil',
        category: 'Office Supplies',
        description: 'A basic #2 Pencil, useful for writing notes.'
      });
      
      // since data is being set and not loaded via fetch, you can call render right away
      this.render();
    },
    
    render: function(){
      // apply the compiled html template to this view's jquery element
      this.$el.html(this.template({
        product: this.model.toJSON()
      }));
      
      // return this for chaining
      return this;
    }
  });
  
  // return the created view
  return HomeViewPartE;
});
</code></pre>
      <div class="fig-title">root/app/views/home/part-e.js</div>
    </div>

    <p>
      There is only one really main change between part-e and part-d and that is 
      instead of sending the entire product model, we call the product model's 
      <strong>toJSON()</strong> method, which creates a plain object with the property and values 
      of each attribute defined in the model.
    </p>

    <h2>Update Template</h2>
    <p>
      Now that we changed the data to the template from a Backbone Model to a plain object, 
      we can no longer call any of the models methods, such as <strong>get()</strong>. With that being said, 
      we will have to update our html to reflect those changes. If you haven't already, open <b>root/index.html</b> in a 
      text editor, and add the following html inbetween the script 
      template <b>tplHomePartE</b>.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;h1 class="text-center"&gt;Products&lt;/h1&gt;
&lt;div class="heading-group"&gt;
  &lt;h2&gt;&lt;%= product.name %&gt;&lt;/h2&gt;
  &lt;h3 class="subheading"&gt;&lt;%= product.category %&gt;&lt;/h3&gt;
&lt;/div&gt;
    
&lt;p&gt;&lt;%= product.description %&gt;&lt;/p&gt;      
</code></pre>
      <div class="fig-title">root/index.html (#tplHomePartE)</div>
    </div>

    <h2>Update App</h2>
    <p>
      Now you just need to update the app file to use the update home view. Open 
      <b>root/app/app.js</b>, and edit the definintion for the home view file like shown below.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'views/home/part-e'
], function(HomeView){
  var App = {
    _curView: null,
    
    initialize: function(){
      // start the application with the HomeView
      this._curView = new HomeView();
    }
  };
  
  return App;
});
</code></pre>
      <div class="fig-title">root/app/app.js</div>
    </div>

    <h2>Refresh index.html in Browser</h2>
    <p>
      Once you refresh your index.html file in your browser, you should now see 
      the same results as part-d.
    </p>
    <div class="fig">
      <img src="images/backbone-tutorial-fig3_4b.jpg">
      <div class="fig-title">Fig 3.4c (root/index.html)</div>
    </div>

    <p>
      Although, part-d and part-e gets the same result, part-e allows for a more simplistic approach for interacting 
      with the model's data. It also allows for a separate developer in charge 
      of template creation to not have to worry about what framework is being used 
      for the model, but can just deal with the model data in a easier dot syntax. 
      Also, this allows for separating as much logic from the template as possible.
    </p>
  </section>
  <!-- End 3.4 Implement Product Model -->

  <!-- 3.5 What is a Collection? -->
  <section id="3.5">
    <header>
      <h1>3.5 What is a Collection?</h1>
    </header>
    <p>
      While a model contains attributes of a object, a collection contains multiple 
      instances of a model. Basically, think of it as a list of models that you can 
      manipulate as an entire group.
    </p>
    <p>
      A <b>Backbone Collection</b> has many useful features out of the box, which include but not limited to:
    </p>
    <ul>
      <li>Looping through items in the collection using the each method.</li>
      <li>Getting items based off of attribute values or model id.</li>
      <li>Updating items from the collection.</li>
      <li>Removing items from the collection based on a single model or an array of models.</li>
      <li>Sorting based on a comparable value(s).</li>
      <li>Triggering and listening (pub/sub) to events on all the items in the collection.</li>
    </ul>
  </section>
  <!-- End 3.5 What is a Collection? -->

  <!-- 3.6 Basic Collection -->
  <section id="3.6">
    <header>
      <h1>Basic Collection</h1>
    </header>
    <p>
      To create a <b>Backbone Collection</b>, all that is required is to follow the same convention 
      we use for our views and models by extending the <b>Backbone Collection Class</b>. 
      Lets use our <b>UserModel</b> we made in <a href="#3.2">Basic Model</a> and create a collection 
      of users.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">var UserModel = Backbone.Model.extend({
  defaults: {
    username: '',
    firstname: '',
    lastname: '',
    accountType: 'general'
  }
});
     
var UserCollection = Backbone.Collection.extend({
  model: UserModel,

  toString: function(){
    var str = '';

    // loop through all items in collection
    users.each(function(user, index){
      str += user.get('username');

      // add comma separator if not the last user
      if(index < users.length - 1){
        str+= ', '
      }
    });

    return str;
  }
});

// can pass user model data as plain object since we defined a model to the collection 
// that will automatically will create a new UserModel instance
var users = new UserCollection([
  {
    username    : 'admin',
    firstname   : 'Big',
    lastname    : 'Boss',
    accountType : 'admin'
  },
  {
    username  : 'user1',
    firstname : 'John',
    lastname  : 'Smith' 
  },
  new UserModel({
    username  : 'user2',
    firstname : 'Jane',
    lastname  : 'Doe'
  })
]);

// find a specific user based on an attribute value
var myUser = users.findWhere({
  username: 'user2'
});

myUser.get('firstname'); // returns 'Jane'

// get number of items in collection
users.length; // returns 3

// add user to collection
users.add({
  username: 'deleteme',
  firstname: 'Delete',
  lastname: 'Me'
});

// users length has been updated
users.length; // returns 4

// remove user from collection
users.remove(users.findWhere({
  username: 'deleteme'
}));

// users length has been updated
users.length; // returns 3

// toString
console.log(users.toString()); // admin, user1, user2

// sorting
// change comparator to the lastname attribute
// comparator can be a function
users.comparator = 'lastname';

// resort the collection
users.sort();

// show update
console.log(users.toString()); // admin, user2, user1
</code></pre>
      <div class="fig-title">Backbone Collection Examples</div>
    </div>
    <p>
      The code above gives you a quick run down on some of the basic features of collections, 
      and how they interact with models associated to them. With all this in mind, 
      we will now begin creating and integrating a Product Collection into our application.
    </p>
  </section>
  <!-- End 3.6 Basic Collection -->

  <!-- 3.7 Create Product Collection -->
  <section id="3.7">
    <header>
      <h1>3.7 Create Product Collection</h1>
    </header>
    <p>
      Go ahead and open <b>root/app/collections/product.js</b> and add the following code 
      to create our product collection.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'backbone',
  'models/product'
], function(Backbone, ProductModel){
  // create class
  var ProductCollection = Backbone.Collection.extend({
    model: ProductModel
  });
  
  // return created class
  return ProductCollection;
});    
</code></pre>
      <div class="fig-title">root/app/collections/product.js</div>
    </div>
    <p>
      As you can probably tell, there really isn't much to the collection class, however 
      for our example that is all that is required to make it work for now. We will come back 
      to it later.
    </p>
  </section>
  <!-- End 3.7 Create Product Collection-->

  <!-- 3.8 Implement Product Collection -->
  <section id="3.8">
    <header>
      <h1>3.8 Implement Product Collection</h1>
    </header>
    <p>
      Open up <b>root/app/views/home/part-f.js</b>, and add the following code to get everything setup 
      for our template to interact with a collection of products.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  'underscore',
  'jquery',
  'backbone',
  'collections/product',
  'models/product'
], function(_, $, Backbone, ProductCollection, ProductModel){
  var HomeViewPartF = Backbone.View.extend({
    el: '#view-content',

    template: _.template($('#tplHomePartF').html()),

    model: null,

    initialize: function(){
      this.loadModel();
    },

    loadModel: function(){
      this.model = new ProductCollection([
        new ProductModel({
          name: 'Pencil',
          category: 'Office Supplies',
          description: 'A basic #2 Pencil, useful for writing notes.'
        }),
        new ProductModel({
          name: 'Notebook',
          category: 'Office Supplies',
          description: 'A book for writing down your thoughts.'
        }),
        new ProductModel({
          name: 'CD Player',
          category: 'Electronics',
          description: 'Plays your music cds.'
        })
      ]);
      
      // since data is being set and not loaded via fetch, you can call render right away
      this.render();
    },

    render: function(){
      // apply the compiled html template to this view's jquery element
      this.$el.html(tpl({
        products: this.model
      }));
      
      // return this for chaining
      return this;
    }
  });
  
  // return the created view
  return HomeViewPartF;
});     
</code></pre>
      <div class="fig-title">root/app/views/home/part-f.js</div>
    </div>
    <p>
      Our loadModel method now creates a collection of products instead of a single product, 
      but everything else pretty much can stay the same. Our template now needs some reworking, so 
      we will update that next.
    </p>

    <h2>Update Template</h2>
    <p>
      Open <b>root/index.html</b> in your favorite text editor, and locate the template script tag 
      with the id attribute <b>tplHomePartF</b>, and add the following.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">&lt;h1 class="text-center"&gt;Products&lt;/h1&gt;
&lt;% if(products.length === 0){ %&gt;
  &lt;p&gt;No Products Found&lt;/p&gt;
&lt;% }else{ %&gt;
  &lt;% products.each(function(product){ %&gt;

    &lt;div class="heading-group"&gt;
      &lt;h2&gt;&lt;%= product.get('name') %&gt;&lt;/h2&gt;
      &lt;h3 class="subheading"&gt;&lt;%= product.get('category') %&gt;&lt;/h3&gt;
    &lt;/div&gt;

    &lt;p&gt;&lt;%= product.get('description') %&gt;&lt;/p&gt;
  &lt;% });/* end foreach product */ %&gt;
&lt;% }/* end if-else products found or not */ %&gt;      
</code></pre>
      <div class="fig-title">root/index.html (#tplHomePartF)</div>
    </div>
    <p>
      Throughout our template we have added script logic/code and as long as 
      JavaScript code is within the underscore template delimeters <strong>&lt;% %&gt;</strong>, the 
      JavaScript will be executed, thus why we can use the collections each method and 
      if statements.
    </p>
    <p>
      We first check to see if there are any products available and let the user know 
      that no products where found. If there are products available, we then loop through 
      each product and display the product data to the user in the exact same way we did it with just 
      the one product.
    </p>

    <div class="disclaimer">
      <small>
        <b>Note</b>
        <p>
          I know I said that we should avoid JavaScript logic/code in our templates in 
          <a href="#3.4">3.4 Product Model</a>, however to work with collections it's a 
          little more complex to deal with setting up the view properly. We will go over 
          solutions for this in <a href="backbone-tutorial-part-4.html">Backbone Tutorial Part 4</a>. 
          For now, this will work for what I'm wanting to show at this point in time.
        </p>
      </small>
    </div>

    <h2>Update App</h2>
    <p>
      Once finished updating our template, we need to update our application to use 
      our new view, so open up <b>root/app.js</b> and replace our home view definition to 
      use "part-f" like shown below.
    </p>
    <div class="fig">
      <pre><code class="prettyprint">'use strict';

define([
  <strong>'views/home/part-f'</strong>
], function(HomeView){
  var App = {
    _curView: null,
    
    initialize: function(){
      // start the application with the HomeView
      this._curView = new HomeView();
    }
  };
  
  return App;
});    
</code></pre>
      <div class="fig-title">root/app/app.js</div>
    </div>

    <h2>Refesh index.html in Browser</h2>
    <p>
      Go ahead and refresh <b>root/index.html</b> in your web browser, and you should 
      have the following results.
    </p>
    <div class="fig">
      <img src="images/backbone-tutorial-fig3_8a.jpg">
      <div class="fig-title">Fig 3.8a (root/index.html)</div>
    </div>
  </section>
  <!-- End 3.8 Implement Product Collection -->

  <!-- 3.9 Part 3 Summary -->
  <section id="3.9">
    <header>
      <h1>3.9 Part 3 Summary</h1>
    </header>
    <p>
      You have finally made it to the end of part 3 of 4 of my Backbone Tutorial Guide. 
      We have went over the basics of creating a model by extending Backbone's base 
      model class, used several built-in model methods that Backbone provides us, such as get/set, and
      we have dove into implementing models into our views. Not only that, but we have 
      even taken a look at adding our models into a collection, and using that collection 
      to sort and interact a grouping of models. Finally, we end by showing how a view can interact with a list 
      of items.
    </p>
    <p>
      There is still one more crutial phase in our app that is still missing, and that is 
      allowing a user to add and remove products dynamically, and to store our product data 
      persistantly. We will discuss these last few steps to a completed app in the next section 
      <a href="backbone-tutorial-part-4.html">Backbone Tutorial Part 3</a>. See you there!
    </p>
  </section>
  <!-- End 3.9 Part 2 Summary -->

  <div class="text-center">
    <a href="backbone-tutorial-part-4.html" class="btn btn-primary">Continue to Part 4!</a>
  </div>
</div>